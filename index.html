<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Support Bro Â· It's LITðŸ”¥</title>
    <link rel="stylesheet" href="./public/styles.css?v=20231121">
    
</head>
<body>
    <main class="layout">
        <section class="hero hero-shell">
            <div class="hero-content">
                <img src="./techsupportbrologo.png" alt="Tech Support Bro" class="hero-logo">
                <div class="hero-actions">
                    <button id="startTree" class="primary">Start troubleshooting</button>
                    <a class="secondary" href="https://docs.google.com/forms/d/e/1FAIpQLSfoxhKvog1UU0YnpnK1U1toIyQkNborx3IAVtJOpc-5VwKhAg/viewform?usp=dialog" target="_blank" rel="noopener">
                        Escalate to 'G'
                    </a>
                    <a class="scroll-link" href="#affirmationExperience">
                        Take a motivational break (scroll)
                    </a>
                </div>
            </div>
            <div class="hero-visual">
                <div class="grid-lines"></div>
                <div class="tablet-stage" id="tabletStage">
                    <div class="tablet-shadow"></div>
                    <div class="tablet" id="tabletModel">
                        <div class="tablet-face"></div>
                        <div class="tablet-back">
                            <img class="tablet-back-logo" draggable="false" src="./public/techsupportbrologo.png" alt="Tech Support Bro logo">
                        </div>
                        <div class="tablet-screen">
                            <video autoplay muted loop playsinline style="pointer-events: none;">
                                <source src="./public/ITChatBuddyAvatar.mp4" type="video/mp4">
                                <source src="./public/ITChatBuddyAvatar.mov" type="video/quicktime">
                                Your browser does not support inline video playback.
                            </video>
                            <h2 class="tablet-title">My Name is 'G'</h2>
                            <span class="tablet-caption">"What seems to be the problem?"</span>
                            <div class="tablet-screen-indicator"></div>
                        </div>
                    </div>
                    <div class="floating-badges">
                        <div class="floating-badge">I can't get on the internet</div>
                        <div class="floating-badge">My laptop won't turn on</div>
                        <div class="floating-badge">I forgot my password</div>
                        <div class="floating-badge">My phone is being weird</div>
                    </div>
                </div>
            </div>
        </section>

        <section class="tree-card" id="treePanel">
            <div class="tree-header">
                <div>
                    <p class="node-path" id="nodePath">Start</p>
                    <h2 id="nodeTitle">Choose a Help Topic</h2>
                    <p class="node-summary" id="nodeSummary">Click "Start troubleshooting" to load the root of the decision tree.</p>
                </div>
                <div class="tree-controls">
                    <button class="ghost" id="backBtn" disabled>Back</button>
                    <button class="ghost" id="restartBtn" disabled>Start over</button>
                    <button class="ghost" id="copyPlanBtn" disabled>Copy plan</button>
                </div>
            </div>
            <div class="node-body">
                <div class="node-response" id="nodeResponse">
                    The offline instructions will appear here after you pick a branch.
                </div>
                <div class="node-tags" id="nodeTags"></div>
                <div class="node-links" id="nodeLinks"></div>
                <div class="node-children" id="nodeChildren"></div>
            </div>
        </section>

                <section class="tree-card" style="margin-top: 18px;">
            <div class="tree-header" style="align-items: flex-start; gap: 8px;">
                <div>
                    <p class="node-path">Diagnostics</p>
                    <h2>Quick checks (no terminal)</h2>
                    <p class="node-summary">One-click browser checks: latency test, device inventory, input tester, and screen info. No PowerShell needed.</p>
                </div>
                <div class="tree-controls" style="gap: 8px;">
                    <button class="ghost" id="pingTestBtn">Run ping test</button>
                    <span id="pingResult" class="node-summary" style="min-width: 160px;"></span>
                </div>
            </div>
            <div class="node-body" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px;">
                <div class="child-card">
                    <h3>Network check</h3>
                    <p class="node-summary">Quick latency test to confirm internet reachability.</p>
                    <button class="ghost" id="pingTestBtn2">Run ping test</button>
                </div>
                <div class="child-card">
                    <h3>Devices</h3>
                    <p class="node-summary">List cameras, microphones, and speakers the browser can see.</p>
                    <button class="ghost" id="deviceScanBtn">List devices</button>
                    <pre class="node-summary" id="deviceScanResult" style="white-space: pre-wrap; min-height: 60px;"></pre>
                </div>
                <div class="child-card">
                    <h3>Input tester</h3>
                    <p class="node-summary">Press keys or click to see if input is detected.</p>
                    <button class="ghost" id="inputTestBtn">Start input test</button>
                    <pre class="node-summary" id="inputTestResult" style="white-space: pre-wrap; min-height: 60px;"></pre>
                </div>
                <div class="child-card">
                    <h3>Screen & display</h3>
                    <p class="node-summary">Show resolution, pixel density, and color mode.</p>
                    <button class="ghost" id="screenInfoBtn">Show screen info</button>
                    <pre class="node-summary" id="screenInfoResult" style="white-space: pre-wrap; min-height: 60px;"></pre>
                </div>
            </div>
        </section>


    </main>
    <script src="./public/app.js"></script>
    <script>
        (() => {
            const pingBtns = [document.getElementById('pingTestBtn'), document.getElementById('pingTestBtn2')].filter(Boolean);
            const pingResult = document.getElementById('pingResult');
            const deviceBtn = document.getElementById('deviceScanBtn');
            const deviceResult = document.getElementById('deviceScanResult');
            const inputBtn = document.getElementById('inputTestBtn');
            const inputResult = document.getElementById('inputTestResult');
            const screenBtn = document.getElementById('screenInfoBtn');
            const screenResult = document.getElementById('screenInfoResult');

            const runPing = async () => {
                if (!pingResult) return;
                pingBtns.forEach(b => b.disabled = true);
                pingResult.textContent = 'Testing...';
                const start = performance.now();
                try {
                    await fetch('https://www.google.com/generate_204', { cache: 'no-store' });
                    const ms = Math.round(performance.now() - start);
                    pingResult.textContent = `Online, ~${ms} ms`;
                } catch (e) {
                    pingResult.textContent = 'Offline or blocked';
                } finally {
                    pingBtns.forEach(b => b.disabled = false);
                }
            };

            pingBtns.forEach(btn => btn.addEventListener('click', runPing));

            if (deviceBtn && deviceResult && navigator.mediaDevices?.enumerateDevices) {
                deviceBtn.addEventListener('click', async () => {
                    deviceBtn.disabled = true;
                    deviceResult.textContent = 'Scanning...';
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const lines = devices.map(d => `${d.kind}: ${d.label || 'Unnamed'} (${d.deviceId.slice(0,6)}...)`);
                        deviceResult.textContent = lines.length ? lines.join('
') : 'No devices reported.';
                    } catch (e) {
                        deviceResult.textContent = 'Device list blocked by browser permissions.';
                    } finally {
                        deviceBtn.disabled = false;
                    }
                });
            }

            if (inputBtn && inputResult) {
                const handler = (msg) => {
                    const now = new Date().toLocaleTimeString();
                    inputResult.textContent = `[${now}] ${msg}`;
                };
                inputBtn.addEventListener('click', () => {
                    handler('Listening for key presses and clicks...');
                });
                window.addEventListener('keydown', (e) => handler(`Key: ${e.key}`));
                window.addEventListener('mousedown', (e) => handler(`Mouse click: button ${e.button}`));
            }

            if (screenBtn && screenResult) {
                screenBtn.addEventListener('click', () => {
                    const { width, height } = window.screen;
                    const dpr = window.devicePixelRatio || 1;
                    const dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    screenResult.textContent = `Resolution: ${width} x ${height}
Device pixel ratio: ${dpr}
Color scheme: ${dark ? 'Dark' : 'Light'}`;
                });
            }
        })();
    </script>

    <script>
        (() => {
            const pingBtn = document.getElementById('pingTestBtn');
            const pingResult = document.getElementById('pingResult');
            const copyButtons = Array.from(document.querySelectorAll('button[data-command]'));

            const runPing = async () => {
                if (!pingBtn || !pingResult) return;
                pingBtn.disabled = true;
                pingResult.textContent = 'Testing...';
                const start = performance.now();
                try {
                    await fetch('https://www.google.com/generate_204', { cache: 'no-store' });
                    const ms = Math.round(performance.now() - start);
                    pingResult.textContent = `Online, ~${ms} ms`;
                } catch (e) {
                    pingResult.textContent = 'Offline or blocked';
                } finally {
                    pingBtn.disabled = false;
                }
            };

            if (pingBtn) pingBtn.addEventListener('click', runPing);

            copyButtons.forEach((btn) => {
                btn.addEventListener('click', async () => {
                    const cmd = btn.getAttribute('data-command') || '';
                    try {
                        await navigator.clipboard.writeText(cmd);
                        const old = btn.textContent;
                        btn.textContent = 'Copied';
                        setTimeout(() => (btn.textContent = old), 1400);
                    } catch (e) {
                        alert('Copy failed. You can copy this manually:\n\n' + cmd);
                    }
                });
            });
        })();
    </script>
    <script>
        (() => {
            const stage = document.querySelector('[data-role="affirmation-stage"]');
            const rig = stage?.querySelector('[data-role="affirmation-rig"]');
            const screen = document.getElementById('affirmationScreen');
            const nextBtn = document.getElementById('affirmationNext');
            const timeEl = document.getElementById('affirmationTime');
            const textEl = document.getElementById('affirmationText');
            const tagEl = document.getElementById('affirmationTag');
            const sourceEl = document.getElementById('affirmationSource');
            const tickerEl = document.getElementById('affirmationTicker');

            if (!stage || !rig || !screen) {
                return;
            }

            const isTickerTarget = (event) => {
                if (!tickerEl) {
                    return false;
                }
                if (tickerEl.contains(event.target)) {
                    return true;
                }
                const rect = tickerEl.getBoundingClientRect();
                const buffer = Math.min(6, rect.height * 0.25);
                return event.clientY >= rect.top - buffer && event.clientY <= rect.bottom + buffer;
            };

            const affirmations = [
                {
                    text: 'Your calm presence is a diagnostic tool - breathe and let the next step appear.',
                    tag: 'Grounding',
                    source: "- Message from 'G'"
                },
                {
                    text: 'You have navigated harder days. Trust the resilience you already built.',
                    tag: 'Confidence',
                    source: "- Message from 'G'"
                },
                {
                    text: 'Lead with curiosity, not perfection. Ask the question that unlocks momentum.',
                    tag: 'Leadership',
                    source: "- Message from 'G'"
                },
                {
                    text: 'Unclench your jaw. Breathe into the space you just made.',
                    tag: 'Release',
                    source: "- Message from 'G'"
                },
                {
                    text: 'Hydrate, stretch, then reset your focus. Your mind needs its own buffer.',
                    tag: 'Reset',
                    source: "- Message from 'G'"
                },
                {
                    text: 'Joy is contagious. Share one tiny win before you close your notebook.',
                    tag: 'Connection',
                    source: "- Message from 'G'"
                },
                {
                    text: 'Silence the notifications. Give your attention to one thing that matters.',
                    tag: 'Focus',
                    source: "- Message from 'G'"
                },
                {
                    text: 'You are not behind; you are pacing yourself for a longer season.',
                    tag: 'Perspective',
                    source: "- Message from 'G'"
                }
            ];

            const tickerPhrases = [
                'Focus on your breath',
                'Stand up and stretch',
                'Celebrate tiny wins',
                'Unclench your jaw',
                'Set a two-minute timer to reset',
                'Good energy is a skill',
                'Drink some water',
                'Take a screen break',
                'You are doing great',
                'Progress over perfection'
            ];

            const rotation = { x: -6, y: 18 };
            const idleBase = { x: rotation.x, y: rotation.y };
            const root = document.documentElement;
            const pointer = { active: false, x: 0, y: 0, startX: 0, startY: 0, dragging: false, id: null };
            let driftTimer = null;
            let driftDelayId = null;
            let affirmationIndex = 0;
            let cycleTimer = null;
            const setDragging = (state) => root.classList.toggle('phone-dragging', state);

            document.addEventListener('selectstart', (event) => {
                if (root.classList.contains('phone-dragging')) {
                    event.preventDefault();
                }
            });

            const applyTransform = () => {
                rig.style.transform = `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
                if (screen) {
                    const shiftX = Math.sin(rotation.y * (Math.PI / 180)) * 12;
                    const shiftY = Math.sin(rotation.x * (Math.PI / 180)) * 12;
                    screen.style.setProperty('--bubble-shift-x', `${shiftX}px`);
                    screen.style.setProperty('--bubble-shift-y', `${shiftY}px`);
                    const depthX = shiftX * 1.8;
                    const depthY = shiftY * 1.8;
                    screen.style.setProperty('--mirror-shift-x', `${depthX}px`);
                    screen.style.setProperty('--mirror-shift-y', `${depthY}px`);
                }
            };

            const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

            const beginPointer = (event) => {
                if (isTickerTarget(event)) {
                    return;
                }
                event.preventDefault();
                pointer.active = true;
                pointer.dragging = false;
                pointer.id = event.pointerId;
                pointer.x = event.clientX;
                pointer.y = event.clientY;
                pointer.startX = event.clientX;
                pointer.startY = event.clientY;
                stage.setPointerCapture?.(event.pointerId);
                stopDrift();
            };

            const movePointer = (event) => {
                if (!pointer.active || (pointer.id !== null && event.pointerId !== pointer.id)) return;
                const newX = event.clientX;
                const newY = event.clientY;
                const deltaX = newX - pointer.x;
                const deltaY = newY - pointer.y;
                pointer.x = newX;
                pointer.y = newY;
                if (!pointer.dragging) {
                    const totalMove = Math.hypot(newX - pointer.startX, newY - pointer.startY);
                    if (totalMove < 5) {
                        return;
                    }
                    pointer.dragging = true;
                    setDragging(true);
                }
                rotation.y = clamp(rotation.y + deltaX * 0.2, -35, 35);
                rotation.x = clamp(rotation.x - deltaY * 0.18, -30, 30);
                applyTransform();
            };

            const endPointer = (event) => {
                if (!pointer.active || (pointer.id !== null && event.pointerId !== pointer.id)) return;
                pointer.active = false;
                const wasDragging = pointer.dragging;
                pointer.dragging = false;
                pointer.id = null;
                stage.releasePointerCapture?.(event.pointerId);
                if (wasDragging) {
                    setDragging(false);
                }
                queueDrift();
            };

            const startDrift = () => {
                if (driftTimer) {
                    return;
                }
                let startTime = performance.now();
                const animate = (time) => {
                    const elapsed = (time - startTime) / 1000;
                    const idleX = idleBase.x + Math.sin(elapsed * 0.8) * 4;
                    const idleY = idleBase.y + Math.cos(elapsed * 0.6) * 9;
                    rotation.x = clamp(idleX, -22, 22);
                    rotation.y = clamp(idleY, -40, 40);
                    applyTransform();
                    driftTimer = requestAnimationFrame(animate);
                };
                driftTimer = requestAnimationFrame(animate);
            };

            const stopDrift = () => {
                if (driftTimer) {
                    cancelAnimationFrame(driftTimer);
                    driftTimer = null;
                }
                if (driftDelayId) {
                    clearTimeout(driftDelayId);
                    driftDelayId = null;
                }
            };

            const queueDrift = () => {
                stopDrift();
                idleBase.x = rotation.x;
                idleBase.y = rotation.y;
                driftDelayId = setTimeout(() => {
                    driftDelayId = null;
                    startDrift();
                }, 900);
            };

            const updateTime = () => {
                const date = new Date();
                let hours = date.getHours();
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const ampm = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12;
                hours = hours ? hours : 12;
                if (timeEl) {
                    timeEl.textContent = `${hours}:${minutes} ${ampm}`;
                }
            };

            const buildTicker = () => {
                if (!tickerEl || tickerEl.dataset.initialized) {
                    return;
                }
                const trackContent = tickerPhrases
                    .map((phrase) => `<span>${phrase}</span><span class="dot">&#8226;</span>`)
                    .join('');
                const trackMarkup = `<div class="ticker-track">${trackContent}</div>`;
                tickerEl.innerHTML = `<div class="ticker-wrapper">${trackMarkup}${trackMarkup}</div>`;
                tickerEl.dataset.initialized = 'true';
            };

            const renderAffirmation = () => {
                const current = affirmations[affirmationIndex];
                if (textEl) textEl.textContent = current.text;
                if (tagEl) tagEl.textContent = current.tag;
                if (sourceEl) sourceEl.textContent = current.source;
            };

            const nextAffirmation = () => {
                affirmationIndex = (affirmationIndex + 1) % affirmations.length;
                renderAffirmation();
                restartCycle();
            };

            const startCycle = () => {
                cycleTimer = setInterval(nextAffirmation, 8000);
            };

            const restartCycle = () => {
                clearInterval(cycleTimer);
                startCycle();
            };

            stage.addEventListener('pointerdown', beginPointer);
            stage.addEventListener('pointermove', movePointer);
            stage.addEventListener('pointerup', endPointer);
            stage.addEventListener('pointerleave', endPointer);
            stage.addEventListener('pointercancel', endPointer);

            // Prevent context menu on right-click
            stage.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            screen.addEventListener('pointerdown', (event) => {
                if (isTickerTarget(event)) {
                    return;
                }
                const rect = screen.getBoundingClientRect();
                const ripple = document.createElement('span');
                ripple.className = 'screen-ripple';
                ripple.style.left = `${((event.clientX - rect.left) / rect.width) * 100}%`;
                ripple.style.top = `${((event.clientY - rect.top) / rect.height) * 100}%`;
                screen.appendChild(ripple);
                ripple.addEventListener('animationend', () => ripple.remove());
            });

            nextBtn?.addEventListener('click', nextAffirmation);
            const blockTickerPointer = (event) => {
                event.stopPropagation();
                event.preventDefault();
            };
            ['pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'click'].forEach((type) => {
                tickerEl?.addEventListener(type, blockTickerPointer, true);
            });

            applyTransform();
            queueDrift();
            buildTicker();
            renderAffirmation();
            startCycle();
            updateTime();
            setInterval(updateTime, 15000);
        })();
    </script>
</body>
</html>

